import asyncio
import time
import pytz
from datetime import datetime, time as dt_time, timedelta
from telegram import Update
from telegram.constants import ParseMode
from telegram.ext import Application, ApplicationBuilder, CommandHandler, ContextTypes

from settings import (
    TELEGRAM_BOT_TOKEN, ALLOWED_USER_ID, TZ_NAME, DEFAULT_UNIT,
    SLOT_TIMES, NUM_SCALPING,
    FAIL_ALERT_COOLDOWN_SEC, HEALTH_POLL_SEC
)
from .mexc_api import top_symbols, pick_scalping_signals

VN_TZ = pytz.timezone(TZ_NAME)
_current_unit = DEFAULT_UNIT  # "VND" or "USD"

_last_fail_alert_ts = 0.0
_is_down = False

def guard(update: Update) -> bool:
    return not (ALLOWED_USER_ID and update.effective_user and update.effective_user.id != ALLOWED_USER_ID)

def vn_now_str():
    now = datetime.now(VN_TZ)
    return now.strftime("%H:%M %d/%m/%Y")

def weekday_vi(dt: datetime) -> str:
    names = ["Th·ª© Hai","Th·ª© Ba","Th·ª© T∆∞","Th·ª© NƒÉm","Th·ª© S√°u","Th·ª© B·∫£y","Ch·ªß Nh·∫≠t"]
    return names[dt.weekday()]

def next_slot_info(now: datetime) -> tuple[str, int]:
    today = now.date()
    slots = []
    for hhmm in SLOT_TIMES:
        h, m = map(int, hhmm.split(":"))
        slots.append(VN_TZ.localize(datetime.combine(today, dt_time(h, m))))
    future = [s for s in slots if s > now]
    if future:
        nxt = future[0]
    else:
        h, m = map(int, SLOT_TIMES[0].split(":"))
        nxt = VN_TZ.localize(datetime.combine(today + timedelta(days=1), dt_time(h, m)))
    mins = max(0, int((nxt - now).total_seconds() // 60))
    return nxt.strftime("%H:%M"), mins

# ----- helper cho /top: token trong khung, gi√° in ƒë·∫≠m, b·ªè funding -----
def _fmt_top_line(c: dict, unit: str) -> str:
    sym = c["symbol"].replace("_USDT", "")
    # gi√°
    if unit == "VND":
        price = f"{c['lastPriceVND']:,}‚Ç´".replace(",", ".")
    else:
        price = f"{c['lastPrice']:.4f} USDT".rstrip("0").rstrip(".")
    # Œî24h + m≈©i t√™n
    chg = float(c.get("change24h_pct", 0.0))
    arrow = "üü¢" if chg > 0 else ("üî¥" if chg < 0 else "‚ö™")
    chg_s = f"{arrow} {chg:+.2f}%"
    # d√≤ng hi·ªÉn th·ªã ƒë·∫πp (HTML)
    return f"<code>[ {sym} ]</code>  <b>{price}</b>   Œî24h = {chg_s}"

# ------------- commands -------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not guard(update): return
    await update.effective_chat.send_message(
        "AUTINER ƒë√£ s·∫µn s√†ng.\n"
        "‚Ä¢ /top ‚Äî Top 30 theo ƒë∆°n v·ªã hi·ªán t·∫°i\n"
        "‚Ä¢ /status ‚Äî Ki·ªÉm tra tr·∫°ng th√°i d·ªØ li·ªáu",
        parse_mode=ParseMode.MARKDOWN
    )

# ----- /status: ch·ªâ ngu·ªìn & tr·∫°ng th√°i, kh√¥ng hi·ªÉn th·ªã VND -----
async def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not guard(update): return
    # probe nhanh 1 m√£ ƒë·ªÉ bi·∫øt tr·∫°ng th√°i d·ªØ li·ªáu
    _, live, _ = top_symbols(unit="USD", topn=1)
    text = (
        "üì° Tr·∫°ng th√°i d·ªØ li·ªáu\n"
        "‚Ä¢ Ngu·ªìn: MEXC Futures\n"
        f"‚Ä¢ Tr·∫°ng th√°i: {'LIVE ‚úÖ' if live else 'DOWN ‚ùå'}\n"
    )
    await update.effective_chat.send_message(text)

# ----- /top: g·ªçn, d·ªÖ ƒë·ªçc, b·ªè funding & LIVE -----
async def top_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not guard(update): return
    coins, live, rate = top_symbols(unit=_current_unit, topn=30)
    if not coins:
        await update.effective_chat.send_message("‚ö†Ô∏è Hi·ªán kh√¥ng c√≥ d·ªØ li·ªáu. Th·ª≠ l·∫°i sau nh√©.")
        return

    head = f"üìä Top 30 Futures (MEXC) ‚Äî ƒê∆°n v·ªã: {_current_unit}"
    lines = [head, ""]
    for c in coins:
        lines.append(_fmt_top_line(c, _current_unit))

    await update.effective_chat.send_message(
        "\n".join(lines),
        parse_mode=ParseMode.HTML,
        disable_web_page_preview=True
    )

# ------------- scheduled jobs -------------
async def morning_brief(context: ContextTypes.DEFAULT_TYPE):
    chat_id = ALLOWED_USER_ID
    now = datetime.now(VN_TZ)
    wd = weekday_vi(now)
    coins, live, rate = top_symbols(unit="USD", topn=30)
    if not live or not coins:
        await context.bot.send_message(chat_id, "‚ö†Ô∏è 06:00 kh√¥ng c√≥ d·ªØ li·ªáu LIVE ƒë·ªÉ t·∫°o b·∫£n tin s√°ng. M√¨nh s·∫Ω th·ª≠ l·∫°i slot sau.")
        return

    long_votes = sum(1 for c in coins if c.get("change24h_pct",0)>=0 and c.get("fundingRate",0)>-0.02)
    long_pct = int(round(long_votes * 100 / max(1, len(coins))))
    short_pct = 100 - long_pct

    vols = sorted([c.get("volumeQuote",0) for c in coins])
    med = vols[len(vols)//2] if vols else 0
    filt = [c for c in coins if c.get("volumeQuote",0)>=med]
    filt.sort(key=lambda x: x.get("change24h_pct",0), reverse=True)
    gainers = filt[:5]

    lines = []
    lines.append("Ch√†o bu·ªïi s√°ng nh√© anh Tr∆∞∆°ng ‚òÄÔ∏è")
    lines.append(f"H√¥m nay: {wd}, {now.strftime('%H:%M %d/%m/%Y')}")
    lines.append("\nTh·ªã tr∆∞·ªùng: nghi√™ng v·ªÅ " + ("LONG" if long_pct >= short_pct else "SHORT") + f" (Long {long_pct}% | Short {short_pct}%)")
    lines.append("‚Ä¢ T√≠n hi·ªáu t·ªïng h·ª£p: funding nh√¨n chung c√¢n b·∫±ng, d√≤ng ti·ªÅn t·∫≠p trung mid-cap.")

    if gainers:
        lines.append("\n5 ƒë·ªìng tƒÉng tr∆∞·ªüng n·ªïi b·∫≠t:")
        for i, c in enumerate(gainers, 1):
            sym = c["symbol"].replace("_USDT","")
            chg = c.get("change24h_pct", 0.0)
            vol = c.get("volumeQuote", 0.0)
            lines.append(f"{i}) {sym} ‚Ä¢ {chg:+.1f}% ‚Ä¢ VolQ ~ {vol:,.0f} USDT".replace(",", "."))
    else:
        lines.append("\nH√¥m nay bi√™n ƒë·ªô th·∫•p, ∆∞u ti√™n qu·∫£n tr·ªã r·ªßi ro.")

    lines.append("\nG·ª£i √Ω:")
    lines.append("‚Ä¢ Gi·ªØ k·ª∑ lu·∫≠t TP/SL, ƒë·ª´ng FOMO n·∫øn m·ªü phi√™n.")
    lines.append("‚Ä¢ Ch·ªù t√≠n hi·ªáu 30‚Äô ƒë·∫ßu ti√™n l√∫c 06:15 (m√¨nh s·∫Ω ƒë·∫øm ng∆∞·ª£c tr∆∞·ªõc 60s).")
    lines.append("Ch√∫c anh m·ªôt ng√†y trade th·∫≠t th√†nh c√¥ng! üçÄ")
    await context.bot.send_message(chat_id, "\n".join(lines))

async def macro_daily(context: ContextTypes.DEFAULT_TYPE):
    chat_id = ALLOWED_USER_ID
    await context.bot.send_message(
        chat_id,
        "üìÖ L·ªãch vƒ© m√¥ h√¥m nay (r√∫t g·ªçn):\n‚Ä¢ T·∫°m th·ªùi ch∆∞a k·∫øt n·ªëi ngu·ªìn chi ti·∫øt.\n"
        "‚Ä¢ G·ª£i √Ω: gi·ªØ v·ªã th·∫ø nh·∫π tr∆∞·ªõc c√°c khung gi·ªù ra tin m·∫°nh.",
    )

async def pre_countdown(context: ContextTypes.DEFAULT_TYPE):
    chat_id = ALLOWED_USER_ID
    msg = await context.bot.send_message(chat_id, "‚è≥ T√≠n hi·ªáu 30‚Äô **ti·∫øp theo** ‚Äî c√≤n 60s", parse_mode=ParseMode.MARKDOWN)
    for sec in range(59, -1, -1):
        try:
            await asyncio.sleep(1)
            await context.bot.edit_message_text(
                chat_id=chat_id, message_id=msg.message_id,
                text=f"‚è≥ T√≠n hi·ªáu 30‚Äô **ti·∫øp theo** ‚Äî c√≤n {sec:02d}s",
                parse_mode=ParseMode.MARKDOWN
            )
        except Exception:
            pass

async def send_batch_scalping(context: ContextTypes.DEFAULT_TYPE):
    chat_id = ALLOWED_USER_ID
    signals, highlights, live, rate = pick_scalping_signals(_current_unit, NUM_SCALPING)

    if (not live) or (not signals):
        now = datetime.now(VN_TZ)
        nxt_hhmm, mins = next_slot_info(now)
        await context.bot.send_message(
            chat_id,
            f"‚ö†Ô∏è H·ªá th·ªëng ƒëang g·∫∑p s·ª± c·ªë n√™n **slot {now.strftime('%H:%M')}** kh√¥ng c√≥ t√≠n hi·ªáu.\n"
            f"‚Ü™Ô∏è D·ª± ki·∫øn ho·∫°t ƒë·ªông l·∫°i v√†o slot **{nxt_hhmm}** (kho·∫£ng {mins} ph√∫t n·ªØa)."
        )
        return

    header = f"üìå T√≠n hi·ªáu {NUM_SCALPING} l·ªánh (Scalping) ‚Äî {vn_now_str()}"
    if highlights:
        header += "\n‚≠ê T√≠n hi·ªáu n·ªïi b·∫≠t: " + " | ".join(highlights[:3])
    await context.bot.send_message(chat_id, header)

    for s in signals:
        msg = (
            f"üìà {s['token']} ({s['unit']}) ‚Äî {'üü©' if s['side']=='LONG' else 'üü•'} {s['side']}\n\n"
            f"üü¢ Lo·∫°i l·ªánh: {s['type']}\n"
            f"üîπ Ki·ªÉu v√†o l·ªánh: {s['orderType']}\n"
            f"üí∞ Entry: {s['entry']}\n"
            f"üéØ TP: {s['tp']}\n"
            f"üõ°Ô∏è SL: {s['sl']}\n"
            f"üìä ƒê·ªô m·∫°nh: {s['strength']}%\n"
            f"üìå L√Ω do: {s['reason']}\n"
            f"üïí Th·ªùi gian: {vn_now_str()}"
        )
        await context.bot.send_message(chat_id, msg)

# Health monitor: c·∫£nh b√°o gi√°n ƒëo·∫°n & b√°o ph·ª•c h·ªìi
async def health_probe(context: ContextTypes.DEFAULT_TYPE):
    global _last_fail_alert_ts, _is_down
    chat_id = ALLOWED_USER_ID

    coins, live, rate = top_symbols(unit="USD", topn=1)
    if live and coins:
        if _is_down:
            _is_down = False
            await context.bot.send_message(chat_id, "‚úÖ H·ªá th·ªëng ƒë√£ **ph·ª•c h·ªìi**. T√≠n hi·ªáu s·∫Ω g·ª≠i b√¨nh th∆∞·ªùng ·ªü slot k·∫ø ti·∫øp.")
        return

    now = time.time()
    if (now - _last_fail_alert_ts) >= FAIL_ALERT_COOLDOWN_SEC:
        _last_fail_alert_ts = now
        _is_down = True
        now_vn = datetime.now(VN_TZ)
        nxt_hhmm, mins = next_slot_info(now_vn)
        await context.bot.send_message(
            chat_id,
            f"üö® **C·∫£nh b√°o k·∫øt n·ªëi**: kh√¥ng g·ªçi ƒë∆∞·ª£c d·ªØ li·ªáu LIVE l√∫c {now_vn.strftime('%H:%M')}.\n"
            f"‚Ü™Ô∏è Slot k·∫ø ti·∫øp: **{nxt_hhmm}** (~{mins} ph√∫t). M√¨nh s·∫Ω t·ª± ƒë·ªông th·ª≠ l·∫°i."
        )

def build_app() -> Application:
    app: Application = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("status", status_cmd))
    app.add_handler(CommandHandler("top", top_cmd))

    j = app.job_queue
    # 06:00 ch√†o bu·ªïi s√°ng, 07:00 macro
    j.run_daily(morning_brief, time=dt_time(6,0, tzinfo=VN_TZ))
    j.run_daily(macro_daily,   time=dt_time(7,0, tzinfo=VN_TZ))

    # countdown v√† batch m·ªói slot
    for hhmm in SLOT_TIMES:
        h, m = map(int, hhmm.split(":"))
        # countdown tr∆∞·ªõc 60s
        mm = (m - 1) % 60
        hh = h if m > 0 else (h - 1)
        j.run_daily(pre_countdown,        time=dt_time(hh, mm, tzinfo=VN_TZ))
        j.run_daily(send_batch_scalping,  time=dt_time(h, m,  tzinfo=VN_TZ))

    # health monitor m·ªói 60s
    j.run_repeating(health_probe, interval=HEALTH_POLL_SEC, first=10)

    return app
